#!/usr/bin/env bash

# @ui COFF=0m BOLD=1m ULINE=4m GRAY=38;5;243m
# @off

SELF_PATH=$(realpath "${BASH_SOURCE[0]}")
SELF_DIR="${SELF_PATH%/*}" SELF_DIR="${SELF_DIR:-/}"
SELF="${SELF_PATH##*/}"
IS_APPLET=0
[[ ${0##*/} != "$SELF" ]] && IS_APPLET=1
readonly IS_APPLET
declare -gA UI_VARS

APP_DESC="Description of the application ${SELF}."

init_ui() {
    [[ ! -t 1 && -z $FORCE_COLOR ]] && return
    local line pair ansi_header=$'\e['
    while read -r line; do
        [[ $line == "# @off"* ]] && return
        [[ $line == "# @ui "* ]] && for pair in ${line#\# @ui }; do
            key="${pair%%=*}" val="${pair#*=}"
            declare -gr "${key}=${ansi_header}${val}"
            UI_VARS["$key"]="${ansi_header}${val}"
        done
    done < "$SELF_PATH"
    declare -grA UI_VARS
}

get_funcs() {
    local -a funcs=()
    local name clean
    while read -r _ _ name; do
        [[ $name == __* ]] || continue
        clean=${name#__}
        funcs+=("$clean")
    done < <(declare -F)
    printf "%s\n" "${funcs[@]}"
    return
}

create_link() {
    local -a funcs
    local symlink_dir="${1:-$SELF_DIR}"
    mapfile -t funcs < <(get_funcs)

    [[ -x $SELF_PATH ]] || {
        printf "%s: executable not found: %s\n" "$SELF" "$SELF_PATH" >&2
        return 1
    }
    [[ -z ${funcs[0]} ]] && {
        printf "%s: no commands available.\n" "$SELF" >&2
        return 1
    }
    local status=0 cmd
    for cmd in "${funcs[@]}"; do
        [[ -z $cmd ]] && continue
        local symlink_path="$symlink_dir/$cmd"
        [[ -L $symlink_path && -e $symlink_path ]] || {
            if ln -sf "$SELF_PATH" "$symlink_path"; then
                printf "Created symlink: %s\n" "$symlink_path"
            else
                printf "Failed to create symlink: %s\n" "$symlink_path" >&2
                status=1
            fi
        }
    done
    return $status
}

extract_func_doc() {
    local -x CMD="$1" func_name="__${1}"
    local vars=("CMD" "SELF" "SELF_PATH" "SELF_DIR")
    local export_vars=("${vars[@]}" "${!UI_VARS[@]}")
    (
        export "${export_vars[@]}"
        awk -v target="$func_name" -v var_list="${export_vars[*]}" '
BEGIN { n = split(var_list, keys, " "); state = 0; doc_buffer = "" }
/^# ?\$\$\$/ {
    if (state == 0) { state = 1; doc_buffer = ""; next }
    if (state == 1) { state = 2; next }}
state == 1 { sub(/^#[[:space:]]?/, ""); doc_buffer = doc_buffer $0 "\n" }
$0 ~ "^[[:space:]]*" target "([[:space:]]*\\(|[[:space:]]+)" {
    if (state == 2) {
        for (i = 1; i <= n; i++) {
            key = keys[i];val = ENVIRON[key]
            if (key == "" || val == "") continue
            gsub("\\$\\{" key "\\}", val, doc_buffer)
            gsub("\\$" key, val, doc_buffer)
        }
        printf "%s", doc_buffer; exit 0
    }
    state = 0
}
state == 2 && !/^[[:space:]]*$/ && !($0 ~ "^#") { state = 0 }
END { exit (state == 2 ? 0 : 1) }
        ' "$SELF_PATH"
    )
}

usage_subcmd() {
    local cmd="$1"
    local desc
    if ! desc=$(extract_func_doc "$cmd"); then
        printf "%s: no help available for '%s'\n" "$SELF" "$cmd" >&2
        return 1
    fi
    printf "%s\n" "$desc"
}

usage_main() {
    local -a funcs
    mapfile -t funcs < <(get_funcs)

    cat << EOF
${BOLD}${APP_DESC}${COFF}

${BOLD}${ULINE}Usage:${COFF}
  ${SELF} COMMAND [options...]
  COMMAND [options...]

${BOLD}${ULINE}Options:${COFF}
  -h, --help         Show help information for the specified command

${BOLD}${ULINE}When using ${SELF} directly as COMMAND:${COFF}
  Usage: ${SELF} <options> [arguments...]
  Options:
    -h, --help         Show this help message
    -l, --list         List all available commands
    -L, --link [DIR]   Create symlinks in DIR
               (default: directory of ${SELF})

${BOLD}${ULINE}Available commands:${COFF}
    ${funcs[*]:-  (No commands available)}
EOF
    exit "${1:-0}"
}

run_cmd() {
    local cmd="$1"
    local -a argv=("${@:2}")
    declare -F -- "__${cmd}" > /dev/null || {
        printf "%s: unsupported command: '%s'\n" "$SELF" "$cmd" >&2
        return 1
    }
    case "${argv[0]}" in
        -h | --help)
            usage_subcmd "$cmd"
            return $?
            ;;
    esac
    CMD="$cmd" "__${cmd}" "${argv[@]}"
}

main() {
    init_ui

    local -a cmd_argv
    if [[ ${0##*/} == "$SELF" ]]; then
        local cmd="$1"
        cmd_argv=("${@:2}")
        case "${cmd}" in
            -h | --help)
                usage_main 0
                ;;
            -l | --list)
                get_funcs
                exit $?
                ;;
            -L | --link)
                create_link "${cmd_argv[@]}"
                exit $?
                ;;
        esac
    else
        cmd="${0##*/}"
        cmd_argv=("$@")
    fi

    [[ -z $cmd ]] && usage_main 0
    run_cmd "$cmd" "${cmd_argv[@]}"
}

main "$@"
