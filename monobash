#!/usr/bin/env bash

# @ui COFF=0m BOLD=1m FAINT=2m ITALIC=3m ULINE=4m INVERT=7m HIDE=8m DLINE=9m
# @off

SELF_PATH=$(realpath "${BASH_SOURCE[0]}") SELF="${SELF_PATH##*/}"
SELF_DIR="${SELF_PATH%/*}" SELF_DIR="${SELF_DIR:-/}"
IS_APPLET=$([[ ${0##*/} != "$SELF" ]] && echo 1 || echo 0)
APP_DESC="Description of the application ${SELF}."

init_ui() {
    [[ ! -t 1 && -z $FORCE_COLOR ]] && return
    local line pair key val ansi_header=$'\e['
    declare -gA UI_VARS
    while read -r line; do
        [[ $line == "# @off"* ]] && return
        [[ $line == "# @ui "* ]] && for pair in ${line#\# @ui }; do
            key="${pair%%=*}" val="${pair#*=}"
            declare -g "${key}=${ansi_header}${val}"
            UI_VARS["$key"]="${ansi_header}${val}"
        done
    done < "$SELF_PATH"
}

get_funcs() {
    local -n _ref=${1:-_null}
    mapfile -t _ref < <(compgen -A function -- __)
    _ref=("${_ref[@]#__}")
    [[ -z $1 ]] && ((${#_ref[@]})) && printf "%s\n" "${_ref[@]}"
}

extract_func_doc() {
    local -x CMD="$1" func_name="__${1}"
    local vars=("CMD" "SELF" "SELF_PATH" "SELF_DIR")
    local export_vars=("${vars[@]}" "${!UI_VARS[@]}")
    (
        export "${export_vars[@]}"
        awk -v target="$func_name" -v var_list="${export_vars[*]}" '
/^##/ { sub(/^## ?/, ""); buf = buf ? buf "\n" $0 : $0; next }
$0 ~ "^" target "[ \t]*\\(\\)" {
  if (buf) { n = split(var_list, vars, " ")
    for (i = 1; i <= n; i++) {
      v = vars[i]; if (v in ENVIRON) {
        val = ENVIRON[v]; gsub(/&/, "\\\\&", val)
        gsub("\\$\\{" v "\\}", val, buf)
        gsub("\\$" v "\\>", val, buf)
    } }
  gsub(/\$\{[A-Za-z_][A-Za-z0-9_]*\}|\$[A-Za-z_][A-Za-z0-9_]*/, "", buf)
  print buf; found = 1 } exit }
{ buf = "" }
END { if (!found) exit 1 }
        ' "$SELF_PATH"
    )
}

usage_subcmd() {
    local cmd="${1:-$CMD}" desc
    desc=$(extract_func_doc "$cmd") || {
        printf "%s: no help available for '%s'\n" "$SELF" "$cmd" >&2
        return 1
    }
    printf "%s\n" "$desc"
}

extract_summary() {
    while IFS= read -r line; do
        line="${line#"${line%%[![:space:]]*}"}"
        line="${line%"${line##*[![:space:]]}"}"
        [[ -z $line ]] && continue
        [[ $line =~ ^(Usage|Options|Commands|Args|Arguments): ]] && continue
        [[ $line =~ ^[-=_.]{3,}$ ]] && continue
        printf '%s\n' "$line"
        return
    done
    return 1
}

usage_main() {
    cat << EOF
${BOLD}${APP_DESC}${COFF}

${ULINE}Usage:${COFF}
  ${SELF} COMMAND [options...]
  COMMAND [options...]

${ULINE}Commands:${COFF}
$(
        funcs=()
        get_funcs funcs
        ((${#funcs[@]})) || {
            printf "  (No commands available)\n"
            return
        }
        max=0
        for cmd in "${funcs[@]}"; do
            ((${#cmd} > max)) && max=${#cmd}
        done
        for func in "${funcs[@]}"; do
            summary=$(extract_func_doc "$func" | extract_summary)
            printf "  %-*s   %s\n" "$max" "$func" "${summary:-${FAINT}...${COFF}}"
        done
    )

${ULINE}Options:${COFF}
  -h, --help    Show help message
  -l, --list    List all available commands
EOF
    (($1)) && exit "${2:-0}"
}

run_cmd() {
    local CMD="$1"
    shift
    declare -F -- "__${CMD}" > /dev/null || {
        printf "%s: unsupported command: '%s'\n" "$SELF" "$CMD" >&2
        return 1
    }
    [[ $1 == "--help" || $1 == "-h" ]] && {
        usage_subcmd
        return $?
    }
    "__${CMD}" "$@"
}

main() {
    init_ui
    if ((!IS_APPLET)); then
        local CMD="$1"
        shift
        case "${CMD}" in
            -h | --help) usage_main 1 ;;
            -l | --list)
                get_funcs
                exit 0
                ;;
        esac
    else
        local CMD="${0##*/}"
    fi
    [[ -z $CMD ]] && usage_main 1
    run_cmd "$CMD" "$@"
}

main "$@"
