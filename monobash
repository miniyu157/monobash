#!/usr/bin/env bash

# @ui COFF=0m BOLD=1m FAINT=2m ITALIC=3m ULINE=4m INVERT=7m HIDE=8m DLINE=9m
# @off

SELF_PATH=$(realpath "${BASH_SOURCE[0]}") SELF="${SELF_PATH##*/}"
SELF_DIR="${SELF_PATH%/*}" SELF_DIR="${SELF_DIR:-/}"
IS_APPLET=$([[ ${0##*/} != "$SELF" ]] && echo 1 || echo 0)
APP_DESC="Description of the application ${SELF}."

init_ui() {
    [[ ! -t 1 && -z $FORCE_COLOR ]] && return
    local line pair key val ansi_header=$'\e['
    declare -gA UI_VARS
    while read -r line; do
        [[ $line == "# @off"* ]] && return
        [[ $line == "# @ui "* ]] && for pair in ${line#\# @ui }; do
            key="${pair%%=*}" val="${pair#*=}"
            declare -g "${key}=${ansi_header}${val}"
            UI_VARS["$key"]="${ansi_header}${val}"
        done
    done < "$SELF_PATH"
}

get_funcs() {
    local -n _ref=${1:-_null}
    mapfile -t _ref < <(compgen -A function -- __)
    _ref=("${_ref[@]#__}")
    [[ -z $1 ]] && ((${#_ref[@]})) && printf "%s\n" "${_ref[@]}"
}

create_link() {
    local -a funcs
    get_funcs funcs
    (("${#funcs[@]}")) || {
        printf "%s: no commands available.\n" "$SELF" >&2
        return 1
    }
    local symlink_dir="${1:-$SELF_DIR}" status=0 cmd
    for cmd in "${funcs[@]}"; do
        local symlink_path="$symlink_dir/$cmd"
        [[ $symlink_path -ef $SELF_PATH ]] || {
            if ln -sf "$SELF_PATH" "$symlink_path"; then
                printf "Created symlink: %s\n" "$symlink_path"
            else
                printf "Failed to create symlink: %s\n" "$symlink_path" >&2
                status=1
            fi
        }
    done
    return $status
}

extract_func_doc() {
    local -x CMD="$1" func_name="__${1}"
    local vars=("CMD" "SELF" "SELF_PATH" "SELF_DIR")
    local export_vars=("${vars[@]}" "${!UI_VARS[@]}")
    (
        export "${export_vars[@]}"
        awk -v target="$func_name" -v var_list="${export_vars[*]}" '
BEGIN { n = split(var_list, keys, " "); state = 0; doc_buffer = "" }
/^# ?\$\$\$/ {
    if (state == 0) { state = 1; doc_buffer = ""; next }
    if (state == 1) { state = 2; next }}
state == 1 { sub(/^#[[:space:]]?/, ""); doc_buffer = doc_buffer $0 "\n" }
$0 ~ "^[[:space:]]*" target "([[:space:]]*\\(|[[:space:]]+)" {
    if (state == 2) {
        for (i = 1; i <= n; i++) {
            key = keys[i];val = ENVIRON[key]
            if (key == "" || val == "") continue
            gsub("\\$\\{" key "\\}", val, doc_buffer)
            gsub("\\$" key, val, doc_buffer)
        }
        printf "%s", doc_buffer; exit 0
    }
    state = 0
}
state == 2 && !/^[[:space:]]*$/ && !($0 ~ "^#") { state = 0 }
END { exit (state == 2 ? 0 : 1) }
        ' "$SELF_PATH"
    )
}

usage_subcmd() {
    local cmd="${1:-$CMD}" desc
    desc=$(extract_func_doc "$cmd") || {
        printf "%s: no help available for '%s'\n" "$SELF" "$cmd" >&2
        return 1
    }
    printf "%s\n" "$desc"
}

usage_main() {
    local -a funcs
    get_funcs funcs
    cat << EOF
${BOLD}${APP_DESC}${COFF}

${BOLD}${ULINE}Usage:${COFF}
  ${SELF} COMMAND [options...]
  COMMAND [options...]

${BOLD}${ULINE}Options:${COFF}
  -h, --help         Show help information for the specified command

${BOLD}${ULINE}When using ${SELF} directly as COMMAND:${COFF}
  Usage: ${SELF} <options> [arguments...]
  Options:
    -h, --help         Show this help message
    -l, --list         List all available commands
    -L, --link [DIR]   Create symlinks in DIR
               (default: directory of ${SELF})

${BOLD}${ULINE}Available commands:${COFF}
    ${funcs[*]:-  (No commands available)}
EOF
    exit "${1:-0}"
}

run_cmd() {
    local CMD="$1"
    shift 1
    declare -F -- "__${CMD}" > /dev/null || {
        printf "%s: unsupported command: '%s'\n" "$SELF" "$CMD" >&2
        return 1
    }
    [[ $1 == "--help" || $1 == "-h" ]] && {
        usage_subcmd
        return $?
    }
    "__${CMD}" "$@"
}

main() {
    init_ui
    if [[ ${0##*/} == "$SELF" ]]; then
        local CMD="$1"
        shift
        case "${CMD}" in
            -h | --help) usage_main 0 ;;
            -l | --list)
                get_funcs
                exit 0
                ;;
            -L | --link)
                create_link "$@"
                exit $?
                ;;
        esac
    else
        local CMD="${0##*/}"
    fi
    [[ -z $CMD ]] && usage_main 0
    run_cmd "$CMD" "$@"
}

main "$@"
